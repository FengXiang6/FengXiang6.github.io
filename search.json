[{"title":"数据库复习笔记","date":"2020-09-01T04:35:38.000Z","url":"/2020/09/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["复习","/tags/%E5%A4%8D%E4%B9%A0/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["notes","/categories/notes/"]],"content":"上天保佑我数据库考出好成绩w！ # Chapter 1: Introduction # Characteristics of Database data persistence（数据持久性） convenience in accessing data(数据便利性访问) data integrity（数据完整性） concurrency control for multiple user(多用户并发控制) failure recovery（故障恢复） security control（安全控制） # Chapter 2: Relational Model # Keys superkey: sufficient to identify tuple, e.g. {ID} or {ID, name} or {ID, name, age} candidate key: minimal superkey primary key: one of the candidate key foreign key # Relational Algebra # Basic \\and(and), \\or(or), ¬\\neg¬(not), σ\\sigmaσ(select), Π\\PiΠ(project),⋈\\Join⋈(natural join) for project Π\\PiΠ: Duplicate rows removed from result, since relations are sets # Join r⋈θs=σθ(r×s)r\\Join_\\theta s=\\sigma_\\theta(r\\times s)r⋈θ​s=σθ​(r×s) # Division # Aggregate # Chapter 3: SQL # Sentence # create table # Drop and Alter # Order # Limit # Set operation To retain all duplicates use the corresponding multiset versions union all, intersect all and except all. # Aggregate # Nested exist, not exist # Insert # Update # Chapter 4: Intermediate SQL # Join # Check # Authorization # Chapter 5: Advanced SQL # Function # return integer # return table # Procedure # pesu-function # loop # Trigger # row level referencing old row as: for delete and update referencing new row as: for insert and update # statement level # Chapter 7: Entity-Relational Model # Definition # Entity set Rectangles represent entity sets Attributes listed inside entity rectangle Underline indicates primary key attributes # Relation A relationship is an association among several entities A relationship set is a mathematical relation among n&gt;2n&gt;2n&gt;2 entities, each taken from entity sets: {(e1,e2,...,en)∣e1∈E1,...,en∈En}\\{(e_1,e_2,...,e_n)|e_1\\in E_1,...,e_n\\in E_n\\} {(e1​,e2​,...,en​)∣e1​∈E1​,...,en​∈En​} # Attribute simple and composite(e.g. addres=street+city+state) single-valued and multivalued(e.g. phone_numbers) derived(can be computed from others) # Mapping many to one(—) and one to one(→\\rightarrow→) partial(single line) and total(double line) lower…upper at most one arrow out in one relation # Primary key for entity sets: nothing to say for relationship sets: depends on the mapping cardinality of the relationship set: many to many: PK(R)=PK(E1)∪...∪PK(En)PK(R)=PK(E_1)\\cup...\\cup PK(E_n)PK(R)=PK(E1​)∪...∪PK(En​) one to many|many to one: PK(R)=PK(manyside)PK(R)=PK(manyside)PK(R)=PK(manyside) one to one: PK(R)=PK(eitherside)PK(R)=PK(either side)PK(R)=PK(eitherside) for weak entity sets: no primary keys, only partial keys use dashed line depend on a strong entity set # Chapter 8: Relational Database Design # Functional Dependency In general, α→β\\alpha\\rightarrow\\betaα→β is trivial if β⊆α\\beta\\subseteq\\alphaβ⊆α # closure closure of attribute sets R(A,B,C,D)R(A,B,C,D)R(A,B,C,D),F={A→B,B→C,B→D}F=\\{A\\rightarrow B,B\\rightarrow C,B\\rightarrow D\\}F={A→B,B→C,B→D} A+=ABCD,B+=BCD,C+=CA^+=ABCD,B^+=BCD,C^+=CA+=ABCD,B+=BCD,C+=C closure of functional denpencies for each γ⊆R\\gamma\\subseteq Rγ⊆R, we find the closure γ+\\gamma^+γ+, and for each S⊆γ+S\\subseteq\\gamma^+S⊆γ+, we output a functional denpendency γ→S\\gamma\\rightarrow Sγ→S # canonical cover denote canonical cover of functional dependencies FFF as FcF_cFc​ R=(A,B,C)R=(A,B,C)R=(A,B,C) F={A→BC,B→C,A→B,AB→C}F=\\{A\\rightarrow BC,B\\rightarrow C,A\\rightarrow B,AB\\rightarrow C\\}F={A→BC,B→C,A→B,AB→C} Fc={A→B,B→C}F_c=\\{A\\rightarrow B,B\\rightarrow C\\}Fc​={A→B,B→C} # BCNF # Definition # lossless-join # 3NF # definition BCNF$\\Rightarrow$3NF 100% lossless-join 100% dependencies preserved # decomposition 先算出正则覆盖 然后对于每一个函数依赖，把它们作为一个新的模式 最后如果没有模式包含候选键，就加一个候选键组成的模式 # 4NF # multivalued dependencies # definition # decomposition ??? # Chapter 10: Storage and File Structure # Hierarchy # voliatile voliatile storage cache, main memory non-volatile storage NVM, falsh memory, magnetic disk, optical disk, magnetic tapes # hierarchy primary: cache, main memory secondary: flash memory, magnetic disk tertiary: optical disk, magnetic tapes # Performance # Access time(访问时间) seek time(寻道时间) rotational latency(旋转等待时间) # Data-transfer rate # I/O operations per second(IOPS) # Mean time to failure(MTTF, 平均故障时间) # Organization # Fixed-Length Records # Varaiable-Length Records # Slotted Page Structure # Heap File Oraganization # Sequential File have keys # Buffer Manager # Policy # clock # Chapter 11: Indexing and Hasing # Indicies primary index, secondary index dense index, sparse index # B+ Tree # property inner node(not a root or a leaf): between ⌈n/2⌉\\lceil n/2\\rceil⌈n/2⌉ and nnn children leaf node: between ⌈(n−1)/2⌉\\lceil(n-1)/2\\rceil⌈(n−1)/2⌉ and n−1n-1n−1 values spcial cases： root is not a leaf: at least 2 children root is a leaf: between 0 and (n−1)(n-1)(n−1) values height: no more than ⌈log⌈n/2⌉(K)⌉\\lceil log_{\\lceil n/2\\rceil}(K)\\rceil⌈log⌈n/2⌉​(K)⌉ # operation 插入 若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。 针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。 针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。 删除 删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。 若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。 若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。 若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步 若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步 当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。 例子 a: insert 9 b: insert 10 c: insert 8 d: delete 23 e: delete 19 # estimation # Chapter 12: Query Processing # Token tTt_TtT​: time to transfer one block tSt_StS​: time for one seek cost for bbb block transfers plus SSS seeks: btT+StSbt_T+St_SbtT​+StS​ # selection # A1: linear sequential file scan worst cost =brtT+tS= b_rt_T+t_S=br​tT​+tS​ brb_rbr​ dentoes number of blocks containing records from relation seek一次最开始的block，然后顺序扫描 average cost =(br/2)tT+tS=(b_r/2)t_T+t_S=(br​/2)tT​+tS​ # A2: index scan, primary B±tree index , equality on key cost =(hi+1)(tT+tS)=(h_i+1)(t_T+t_S)=(hi​+1)(tT​+tS​) 每次读入node都需要seek和transfer。一共要处理树高度个node，然后再读入结果的block。 # A3: primary B±tree index, equality on nonkey cost =hi(tT+tS)+tS+tTb=h_i(t_T+t_S)+t_S+t_Tb=hi​(tT​+tS​)+tS​+tT​b Let b = number of blocks containing matching records # A4: secondary B±index on nonkey, equality cost =(hi+m+n)(tT+tS)=(h_i+m+n)(t_T+t_S)=(hi​+m+n)(tT​+tS​) 这里应该是对应的指针有n个，但是放在m个block里面。所以遍历指针的时候要m次seek和transfer，通过指针去找record所在的块的时候又要n次。 # A5 (primary B±index, comparison) # A6 (secondary B±tree index, comparison) # Sorting(external sort-merge) # simplest version # advanced version # Join # # block nested-loop join 只有2个page的情况 前面的部分是inner block，后面的部分是outer block；best case对于内存无限大来说 有M个page的情况 # indexed nested-loop join # merge-join simple version advanced version # hash-join # Chapter 13: Query Optimization # Chapter 14: Transactions # Chapter 15: Concurrency Control # Chapter 16: Recovery System # Chapter 22: Object-Based Databases # Chapter 23: XML"},{"title":"线代2复习笔记","date":"2020-08-30T10:59:56.000Z","url":"/2020/08/30/%E7%BA%BF%E4%BB%A32%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["线性代数","/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"],["复习","/tags/%E5%A4%8D%E4%B9%A0/"]],"categories":[["notes","/categories/notes/"]],"content":"头秃复习线代2，感觉都没学过QAQ # 本征值和三角 有限维非零负向量空间上的每个算子都有本征值。 算子指的是L(V,V)L(V,V)L(V,V)的线性映射，简写作L(V)L(V)L(V)。我们假设空间的维度是nnn，然后找n+1n+1n+1个向量，这样它们一定线性相关。令它们的线性组合为零，则一定有非零系数。这样就可以对以这些系数为系数的算子多项式进行因式分解，而且这个多项式一定是零算子。进一步就可以推得一定有个因式不是单的，也就有了本征值。 在CCC上，每个算子都有上三角矩阵。 用数学归纳法证明。 提示：设U=range(T−λI)U=range(T-\\lambda I)U=range(T−λI)，证明它是不变子空间。利用T∣UT|_{U}T∣U​（数学归纳法），得出小块的上三角。然后找到UUU的基扩充，再加以证明。 顺便提一句，可以由上三角矩阵的对角线确定算子的本征值，不管定义在什么FFF域。 算子（如果有上三角阵）的可逆性等价于对角线全部不为0。 没啥好说的 算子可对角化等价于： 有由本征向量构成的基 可以分解成一维子空间的直和 本征空间维度总和与VVV相等 关于最后一点，其实第二点的一维子空间可以看成所有本征空间的分解。 规范正交化 ej=vj−⟨vj,e1⟩e1−...−⟨vj,ej−1⟩ej−1∣∣vj−⟨vj,e1⟩e1−...−⟨vj,ej−1⟩ej−1∣∣e_j=\\frac{v_j-\\left\\langle v_j,e_1\\right\\rangle e_1-...-\\left\\langle v_j,e_{j-1}\\right\\rangle e_{j-1}}{||v_j-\\left\\langle v_j,e_1\\right\\rangle e_1-...-\\left\\langle v_j,e_{j-1}\\right\\rangle e_{j-1}||}ej​=∣∣vj​−⟨vj​,e1​⟩e1​−...−⟨vj​,ej−1​⟩ej−1​∣∣vj​−⟨vj​,e1​⟩e1​−...−⟨vj​,ej−1​⟩ej−1​​ 正交化过程中，子向量组的张成空间不变。 如span(e1,e2,e3)=span(v1,v2,v3)span(e_1,e_2,e_3)=span(v_1,v_2,v_3)span(e1​,e2​,e3​)=span(v1​,v2​,v3​) 舒尔定理：复向量空间算子关于某个规范正交基有上三角矩阵。 首先它肯定关于某个基有上三角矩阵，然后根据规范正交化过程中子向量组张成空间不变可以推出结论。 里斯表示定理：存在唯一的u∈Vu\\in Vu∈V使得对任意v∈Vv\\in Vv∈V 有ϕ(v)=⟨v,u⟩\\phi(v)=\\left\\langle v,u\\right\\rangleϕ(v)=⟨v,u⟩，其中ϕ\\phiϕ是线性泛函，也就是像空间是一维的。 # 自伴、正规、谱定理 伴随⟨Tv,w⟩=⟨T∗w⟩\\left\\langle Tv,w \\right\\rangle=\\left\\langle T^*w\\right\\rangle⟨Tv,w⟩=⟨T∗w⟩ (λT)∗=λcT∗(\\lambda T)^*=\\lambda^cT^*(λT)∗=λcT∗ M(T∗)=(M(T)T)cM(T*)=(M(T)^T)^cM(T∗)=(M(T)T)c共轭转置 前提是行和列都要用规范正交基表示。 自伴T=T∗T=T^*T=T∗。 自伴算子都有本征值。 自伴算子的本征值都是实的。 在CCC上，任意vvv，⟨Tv,v⟩=0⇒T=0\\left\\langle Tv,v\\right\\rangle=0\\Rightarrow T=0⟨Tv,v⟩=0⇒T=0。 在CCC上，任意vvv，⟨Tv,v⟩\\left\\langle Tv,v\\right\\rangle⟨Tv,v⟩为实数⇒T\\Rightarrow T⇒T自伴。 TTT自伴，任意vvv，⟨Tv,v⟩=0⇒T=0\\left\\langle Tv,v\\right\\rangle=0\\Rightarrow T=0⟨Tv,v⟩=0⇒T=0。 自伴在不变子空间下还是自伴的 第四点说明，在实内积空间上，需要更强的自伴条件，才能推出零算子。 正规TT∗=T∗TTT^*=T^*TTT∗=T∗T 正规当且仅当对任意vvv，有∣∣Tv∣∣=∣∣T∗v∣∣||Tv||=||T^*v||∣∣Tv∣∣=∣∣T∗v∣∣ 若正规，则TTT与T∗T^*T∗具有相同的本征向量，但是对于这个本征向量而言，它对应的本征值互为共轭。 若正规，不同本征值的本征向量正交。 提示： ⟨T∗Tv,v⟩=⟨TT∗v,v⟩\\left\\langle T^*Tv,v\\right\\rangle=\\left\\langle TT^*v,v\\right\\rangle⟨T∗Tv,v⟩=⟨TT∗v,v⟩ ∣(T−λI)v∣=∣(T−λI)∗v∣=∣(T∗−λcI)v∣|(T-\\lambda I)v|=|(T-\\lambda I)^*v|=|(T^*-\\lambda^cI)v|∣(T−λI)v∣=∣(T−λI)∗v∣=∣(T∗−λcI)v∣ (a−b)⟨u,v⟩=⟨au,v⟩−⟨u,bcv⟩=⟨Tu,v⟩−⟨u,T∗v⟩=0(a-b)\\left\\langle u,v\\right\\rangle=\\left\\langle au,v\\right\\rangle-\\left\\langle u,b^cv\\right\\rangle=\\left\\langle Tu,v\\right\\rangle-\\left\\langle u,T*v\\right\\rangle=0(a−b)⟨u,v⟩=⟨au,v⟩−⟨u,bcv⟩=⟨Tu,v⟩−⟨u,T∗v⟩=0 复谱定理F=CF=CF=C：（以下条件等价） TTT是正规的 VVV有一个TTT的本征向量组成的规范正交基 TTT关于某个规范正交基有对角阵 证明正规的时候可以考虑对角阵乘法可以交换。 先由舒尔定理得出关于某规范正交基有上三角阵，再证这个上三角实际上是对角。 实谱定理F=RF=RF=R：（以下条件等价） TTT是自伴的 VVV有一个TTT的本征向量组成的规范正交基 TTT关于某个规范正交基有对角阵 两个谱定理的不同点在于实空间要求更强的自伴条件。 证明：归纳法。先拿出一个特征向量span成一维不变子空间，它的正交补也是不变子空间（维度变小，用归纳法）。这个时候就很自然的找到了对角阵。 # 平方根，等距同构，奇异值分解 正算子：首先自伴。并且任意vvv，有⟨Tv,v⟩≥0\\left\\langle Tv,v\\right\\rangle\\geq0⟨Tv,v⟩≥0。以下条件等价： 正的 自伴的而且所有本征值非负 有正的平方根 有自伴的平方根 存在算子RRR使得T=R∗RT=R^*RT=R∗R ⟨Tv,v⟩=⟨av,v⟩=a⟨v,v⟩\\left\\langle Tv,v\\right\\rangle=\\left\\langle av,v\\right\\rangle=a\\left\\langle v,v\\right\\rangle⟨Tv,v⟩=⟨av,v⟩=a⟨v,v⟩ 谱定理有本征向量的规范正交基。然后由Rej=λjejRe_j=\\sqrt{\\lambda_j}e_jRej​=λj​​ej​确定算子RRR 正的肯定是自伴的 T=R2=R∗RT=R^2=R^*RT=R2=R∗R ⟨Tv,v⟩=⟨R∗Rv,v⟩=⟨Rv,Rv⟩\\left\\langle Tv,v\\right\\rangle=\\left\\langle R^*Rv,v\\right\\rangle=\\left\\langle Rv,Rv\\right\\rangle⟨Tv,v⟩=⟨R∗Rv,v⟩=⟨Rv,Rv⟩ 每个正算子都有唯一的正平方根。 等距同构算子：∣∣Sv∣∣=∣∣v∣∣||Sv||=||v||∣∣Sv∣∣=∣∣v∣∣。以下条件等价： 等距同构 保内积（因为内积可以由范数算出） 规范正交基e1,e2,...e_1,e_2,...e1​,e2​,...的映射Se1,Se2,...Se_1,Se_2,...Se1​,Se2​,...也规范正交 SS∗=S∗S=ISS^*=S^*S=ISS∗=S∗S=I S∗S^*S∗是等距同构 SSS是可逆的并且S−1=S∗S^{-1}=S^*S−1=S∗ F=CF=CF=C，SSS等距同构等价于VVV有一个由SSS的本征向量组成的规范正交基并且本征值绝对值为1 极分解：设T∈L(V)T\\in L(V)T∈L(V).则有一个等距同构S∈L(V)S\\in L(V)S∈L(V)使得T=ST∗TT=S\\sqrt{T^*T}T=ST∗T​（T∗TT^*TT∗T一定是正算子） 考虑F=CF=CF=C的情况，由于SSS和T∗T\\sqrt{T^*T}T∗T​ （唯一的正平方根，自伴）都是正规的，故根据复谱定理可以找到两组规范正交基使得他们对角化。 奇异值：就是T∗T\\sqrt{T^*T}T∗T​的本征值，而且要重复dimE(λ,T∗T)dimE(\\lambda,\\sqrt{T^*T})dimE(λ,T∗T​)次。由于是正算子的本征值，所以肯定非负。也可以算T∗TT^*TT∗T的本征值 λ\\lambdaλ 然后取非负平方根，重复dimE(λ,T∗T)dimE(\\lambda,T^*T)dimE(λ,T∗T) 奇异值分解：Tv=s1⟨v,e1⟩f1+...+sn⟨v,en⟩fnTv=s_1 \\left\\langle v,e_1\\right\\rangle f_1+...+s_n\\left\\langle v,e_n\\right\\rangle f_nTv=s1​⟨v,e1​⟩f1​+...+sn​⟨v,en​⟩fn​ M(T,(e1,...,en),(f1,...,fn))=M(T,(e_1,...,e_n),(f_1,...,f_n))= M(T,(e1​,...,en​),(f1​,...,fn​))= [s10...0sn]\\left[\\begin{matrix} s_1 &amp; &amp; &amp; &amp; 0\\\\ &amp; . &amp; &amp; &amp; \\\\ &amp; &amp; . &amp; &amp; \\\\ &amp; &amp; &amp; . &amp; \\\\ 0 &amp; &amp; &amp; &amp; s_n \\end{matrix}\\right] ⎣⎢⎢⎢⎢⎡​s1​0​.​.​.​0sn​​⎦⎥⎥⎥⎥⎤​ # 广义本征向量、幂零算子 之前一直搞混：本征值还是原来的本征值，不过相应的本征空间扩大了（狭义→\\rightarrow→广义） 零空间序列单调不减，且在某点停止增长。 零空间序列指null(T0),null(T1),...,null(Tk),...null(T^0),null(T^1),...,null(T^k),...null(T0),null(T1),...,null(Tk),... 显然这个零空间是越来越大的，因为线性映射将0映射到0 但是他有个性质，如果令n=dimVn=dimVn=dimV,则有null(Tn)=null(Tn+1)=...null(T^n)=null(T^{n+1})=...null(Tn)=null(Tn+1)=...，也就是说超过维度就停止增长 当然，如果满足了某点null(Tm)=null(Tm+1)null(T^m)=null(T^{m+1})null(Tm)=null(Tm+1)，那么之后它也会停止增长 V=null(TdimV)⊕range(TdimV)V=null(T^{dimV})\\oplus range(T^{dimV})V=null(TdimV)⊕range(TdimV) 然后就引入广义本征向量： 我们说λ\\lambdaλ是算子TTT的一个本征值，vvv是对应于这个本征值的广义本征向量，如果存在正整数jjj使得(T−λI)jv=0(T-\\lambda I)^jv=0(T−λI)jv=0。 需要注意的是，这里的本征值还是根据(T−λI)w=0(T-\\lambda I)w=0(T−λI)w=0弄出来的，www是狭义本征向量。 然后我们有一个非常好的性质，那就是广义本征空间G(λ,T)=null(T−λI)dimVG(\\lambda,T)=null(T-\\lambda I)^{dimV}G(λ,T)=null(T−λI)dimV。 证明这个需要用到上面的零空间增长理论。 同样的，广义本征向量相互之间线性无关。 而且，V=G(λ1,T)⊕...⊕G(λm,T)V=G(\\lambda_1,T)\\oplus...\\oplus G(\\lambda_m,T)V=G(λ1​,T)⊕...⊕G(λm​,T) 这同样说明，VVV有一组由广义本征向量构成的基。 上面两条仅对复向量空间适用。 对于复向量空间，VVV可以关于这样的基有分块上三角矩阵。每个小块的对角线都是相同的本征值，块的大小就是代数重数。 然后来讲幂零算子，存在正整数jjj使得Nj=0N^j=0Nj=0，这东西⇒NdimV=0\\Rightarrow N^{dimV}=0⇒NdimV=0 它可以关于某一个基长成一个上三角阵的形式（对角线也为0） 这个基是这么取出来的，先取nullNnullNnullN的基，然后扩充成null(N2)null(N^2)null(N2)的基，然后继续… λ\\lambdaλ的代数重数 =dimG(λ,T)=dimG(\\lambda,T)=dimG(λ,T) λ\\lambdaλ的几何重数 =dimE(λ,T)=dimE(\\lambda,T)=dimE(λ,T) 然后下面这几条我也不知道有什么作用： 恒等加幂零有平方根（参考1+x\\sqrt{1+x}1+x​的泰勒级数） CCC上的可逆算子有平方根 BTW，极小多项式的零点恰好是本征值 # 复化 实空间VVV的标量域是RRR，复化VCV_CVC​的标量域是CCC 我们有以下性质： dimVVV=dimVCV_CVC​,VVV的基也是VCV_CVC​的基 TC(u+iv)=Tu+iTvT_C(u+iv)=Tu+iTvTC​(u+iv)=Tu+iTv TCT_CTC​的矩阵等于TTT的矩阵，这个矩阵要关于共同的基 TCT_CTC​的极小多项式等于TTT的极小多项式 TTT和TCT_CTC​有共同的实本征值 如果一个数是TCT_CTC​的本征值，那么它的复共轭也是TCT_CTC​的本征值。而且他们的广义本征向量互为共轭。 奇数维向量空间上的算子必有本征值（其实只用考虑实空间） 这是因为对于TCT_CTC​，复本征值成对出现，所以重数之和为偶数。那么剩下的本征值必然是实本征值，而TTT和TCT_CTC​共享实本征值，因此得证。 每个算子都有一维或者二维不变子空间 TCT_CTC​必定有本征值a+bia+bia+bi TC(u+vi)=(a+bi)(u+vi)=(au−bv)+(av+bu)i=Tu+iTvT_C(u+vi)=(a+bi)(u+vi)=(au-bv)+(av+bu)i=Tu+iTvTC​(u+vi)=(a+bi)(u+vi)=(au−bv)+(av+bu)i=Tu+iTv 可以看出Tu,Tv∈span(u,v)Tu,Tv\\in span(u,v)Tu,Tv∈span(u,v) # 实空间的正规、等距同构算子描述 以下都是实空间！！！ 以下条件等价： TTT是正规的 VVV有规范正交基使得TTT关于这个基有分块对角矩阵，对角线上的每个块是1×11\\times11×1矩阵，或者是形如 [a−bba]\\left[\\begin{matrix}a&amp;-b\\\\b&amp;a\\end{matrix}\\right] [ab​−ba​] 的2×22\\times22×2矩阵，其中b&gt;0b&gt;0b&gt;0。这个矩阵是非自伴的正规算子（不变子空间）会有的。 以下条件等价： SSS是等距同构 VVV有规范正交基使得SSS关于这个基具有分块对角矩阵，对角线上的每个块是由1或-1构成的1×11\\times11×1矩阵，或者是形如 [cosθ−sinθsinθcosθ]\\left[\\begin{matrix}cos\\theta&amp;-sin\\theta\\\\sin\\theta&amp;cos\\theta\\end{matrix}\\right] [cosθsinθ​−sinθcosθ​] 的2×22\\times22×2矩阵，其中θ∈(0,π)\\theta\\in(0,\\pi)θ∈(0,π) "},{"title":"kotoba 言语","date":"2020-08-28T06:03:51.000Z","url":"/2020/08/28/kotoba-%E8%A8%80%E8%AF%AD/","tags":[["感性","/tags/%E6%84%9F%E6%80%A7/"],["随笔","/tags/%E9%9A%8F%E7%AC%94/"]],"categories":[["life","/categories/life/"]],"content":"2020-08-28 暖雪飘落——《来自风平浪静的明天》 安倍晋三说自己计划辞职了，爷青结 考试好像还有很远，但其实很近 线代2要挂了啊喂"},{"title":"make your own linux distro","date":"2020-08-24T14:27:36.000Z","url":"/2020/08/24/make-your-own-linux-distro/","tags":[["发行版","/tags/%E5%8F%91%E8%A1%8C%E7%89%88/"]],"categories":[["linux","/categories/linux/"]],"content":"自己写的finux发行版，根文件系统的构建还差点自主性。 # Finux 帮助手册 # 1 安装Finux # 1.1 获取Finux镜像 在与guide目录同级的iso目录下找到finux.iso镜像文件。 # 1.2 安装测试平台 基于现有的资源，本人分别在VMWare虚拟机和Windows10 x64平台上进行了Finux发行版安装的测试。 # 1.3 在VMWare虚拟机上部署Finux # 1.3.1 创建虚拟机 打开VMWare Workstation，在笔者的测试机器上，版本为WORKSTATION 15.5 PRO。 选择文件-&gt;新建虚拟机打开新建虚拟机向导界面。 在开启的新建虚拟机向导界面选择自定义(高级)(C)，点击下一步(N)&gt;。 硬件兼容性选择默认的Workstation 15.x，点击下一步(N)&gt;。 安装来源选择安装程序光盘映像文件(iso)(M)，点击浏览(R)...选择在之前取得的finux.iso镜像文件。此时会给出警告*“无法检测此光盘映像中的操作系统。您需要指定要安装的操作系统。’’*不需要理会此条信息，点击下一步(N)&gt;。 客户机操作系统选择其他(O)，**版本(V)**选择其他64位，点击下一步(N)&gt;。 虚拟机名称和位置请用户自行选择，点击下一步(N)&gt;。 处理器配置请用户自行选择，点击下一步(N)&gt;。笔者此处设置处理器数量为1，每个处理器内核数量为2。 此虚拟机的内存请用户自行选择，至少分配1.5GB，点击下一步(N)&gt;。笔者此处设置内存为4GB。 网络类型选择使用网络地址转换(NAT)(E)，点击下一步(N)&gt;。 SCSI控制器选择LSI Logic SAS(S)，点击下一步(N)&gt;。 虚拟磁盘类型选择SCSI(S)，点击下一步(N)&gt;。 磁盘选择创建新虚拟磁盘(V)，点击下一步(N)&gt;。 最大磁盘大小指定为至少10GB，选择将虚拟磁盘拆分成多个文件(M)，点击下一步(N)&gt;。笔者此处设置为30GB。 磁盘文件命名请用户自行选择，点击下一步(N)&gt;。 在已准备好创建虚拟机界面，检查虚拟机配置，点击完成。 # 1.3.2 配置虚拟机网络 在刚刚创建的虚拟机选项卡中， 点击工具栏编辑-&gt;虚拟网络编辑器。 在虚拟网络编辑器界面，找到类型为NAT模式的虚拟网络适配器名称VMnet8。您可能需要点击更改设置来获得管理员权限以浏览全部配置。 退出虚拟网络编辑器。依次打开Windows电脑上的控制面板-&gt;网络和Internet-&gt;网络和共享中心-&gt;更改适配器设置，找到正在使用到的网卡设备。笔者的电脑上为 Intel® Wireless-AC 9560。右键点击此设备，选择属性-&gt;共享，勾选允许其他网络用户通过此计算机的Internet来连接，家庭网络连接选择VMware Network Adapter VMnet8，点击确定。 # 1.3.3 启动虚拟机 在刚刚创建的虚拟机选项卡中， 点击开启此虚拟机，然后进入1.5 通用安装步骤。 # 1.4 在Windows10 x64上部署Finux # 1.4.1 移动存储介质 请您准备一块移动存储介质以供烧录镜像。笔者选用的是USB存储卡。 # 1.4.2 准备硬盘空间 请您准备一块空闲的磁盘空间以供Finux安装使用。 右键Windows开始菜单，选择磁盘管理打开界面。 您可以选择使用一整块磁盘安装Finux，或者使用磁盘中的一部分来安装。如果使用后者，请先右键某一块磁盘，选择压缩卷来获得一块空闲空间。如果使用前者，请确保格式化磁盘之前已经备份好数据，此操作无法复原。 现在您已经准备好Finux系统所需要的硬盘空间了。 # 1.4.3 烧录镜像 现在您需要将Finux镜像烧录进U盘以使得它成为可引导启动的liveCD。 在下载rufus软件。 打开rufus，设备选择准备好的移动存储介质，引导类型选择准备好的finux.iso，分区类型选择MBR，目标系统类型选择BIOS(或UEFI-CSM)。文件系统选择FAT32(默认)，簇大小选择16K字节(默认)，然后点击开始进行烧录。 现在您已经准备好Finux的安装引导硬盘了。 # 1.4.4 调整启动选项 重启计算机，进入主板BIOS界面。不同计算机进入BIOS界面的方法不同，BIOS的用户交互界面也不同。 在笔者的计算机上，为按F2键进入界面。 调整启动模式为Legacy启动，即从BIOS启动。 允许USB启动。 调整USB介质为第一启动项。 保存并退出BIOS界面，进入1.5 通用安装步骤。 # 1.5 通用安装步骤 # 1.5.1 进入安装系统 等待引导程序初始化完成后，用户将看到isolinux引导界面。 选择第一项Enter live system，回车进入安装系统。 KDE桌面环境会自动加载，在经历加载动画后，您就会进入Finux系统桌面。 # 1.5.2 安装Finux 双击启动桌面上的Install程序，进入到安装程序界面。 选择您需要的语言，点击下一步(N)。默认语言为简体中文(中国)。 选择您的位置和时区，点击下一步(N)。默认为亚洲上海。 选择您的键盘型号，点击下一步(N)。笔者选择为English(US) Default。 选择您的分区方式，点击下一步(N)。笔者建议对于使用整块磁盘的用户，直接选择抹除磁盘方式安装。 检查您的计算机配置，点击下一步(N)。 等待安装完成，点击完成重新启动计算机，进入新系统。 # 1.6 可能出现的问题 由于rufus烧录自动添加了isolinux的原因，可能会覆盖原有的引导配置文件，导致启动时识别失败出现如下界面。在此界面下，用户只需输入/casper/vmlinuz initrd=/casper/initrd.lz boot=casper即可重新进入live系统进行Finux安装。这个操作等同于在isolinux引导界面选择Enter live system。 在VMWare虚拟机上启动Finux-liveCD/Finux时，会出现NetworkManager加载失败的现象。这是由于dhclient进程没能正确初始化引起的，造成原因可能与VMWare的网卡适配器有关。此时用户可以使用alt+ctrl+T呼出终端窗口，输入sudo /sbin/dhclient重新加载dhclient进程即可。 # 2 使用Finux # 2.1 启动Finux 安装后的Finux使用grub作为引导程序，因此引导界面略有不同： # 2.2 系统信息 # 2.3 基本命令使用 # 2.4 基本软件使用 # 3 构建Finux 构建Finux的过程即为构建自制发行版的过程。在本章节中，笔者将在分析linux发行版组成要素的同时讨论如何在实践中构建一个发行版。 # 3.1 发行版的基本构成要素 一个通用的发行版包含以下四个要素：kernel，file-system，bootloader和software。 # 3.1.1 kernel # 3.1.1.1 vmlinuz 我们平时指代的由linus开发的linux，其实指的是linux的内核。linux的内核是由C语言编写的，它负责存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信，以及系统的初始化、系统调用等。在linux系统中，内核的存在形式往往是位于/boot目录下的vmlinuz镜像文件，它是内核编译的产物。 # 3.1.1.2 initrd/initramfs 与kernel镜像成对出现的往往是initrd或者initramfs。bootloader加载系统时，首先装入kernel。然后kernel需要执行文件系统下的/sbin/init，读取这个文件就必须先mount根文件系统。initrd/initramfs可以看做是kernel加载真正根文件系统之前要加载的虚拟根文件系统，它们作为中间跳板被使用。 initramfs 的工作方式相比较来说更加简单直接一些：启动的时候加载内核和 initramfs 到内存执行，内核初始化之后，切换到用户态执行 initramfs的程序/脚本，加载需要的驱动模块、必要配置等，然后加载 rootfs 切换到真正的 rootfs 上去执行后续的 init 过程。 # 3.1.2 file-system 尽管内核是linux的核心，但文件却是用户与操作系统交互所采用的主要工具。这对linux来说尤其如此，这是因为在UNIX传统中，它使用文件I/O机制管理硬件设备和数据文件。 linux的文件系统遵循固定的架构，它包括根目录/以及其子目录/bin，/boot，/home，/root，/var等。它们各有用途，例如，/bin目录下就存放了供用户使用的linux命令的可执行文件，如bash/cat/cp/mv等。 # 3.1.3 bootloader BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。 # 3.1.4 software 一个linux发行版往往有大量的定制软件包。例如，广受欢迎的Linux Mint就有“开箱即用”的美誉，免去用户在安装系统后还要自己安装一系列满足基本使用需求软件的麻烦。 为了管理这些软件包，常常还需要有软件包管理器。例如debian系的apt和arch系的pacman。 # 3.2 构建根文件系统工作环境 # 3.2.1 Debootstrap debootstrap是debian/ubuntu下的一个工具，用来构建一套基本的系统(根文件系统)。生成的目录符合Linux文件系统标准(FHS)，即包含了/boot、/etc、/bin、/usr等等目录，但它只能算是“基本的系统”，没有强大的功能。 首先从debian软件仓库获取debootstrap软件包： 安装debootstrap软件包： ❕ 如果您正位于ubuntu操作系统上，这步操作将有不同。debian仓库中的debootstrap和ubuntu中的debootstrap不同，它们构建的文件系统有些许区别。 使用debootstrap从清华源拉取debian的文件系统： --arch选项用来指定要拉取文件系统对应的CPU架构，笔者的CPU架构是x86_64，因此选择amd64。读者可以使用uname -a命令进行查看。buster是debian系统的版本号，这里也可以选择其他版本号。 现在您已经具有一个基本完备的debian文件系统。 # 3.2.2 更自由化的构建方式 LFS，Linux From Scratch，是一种从源码构建Linux系统的方法。它的自由化可定制程度极高，选择安装哪些内置软件包全部由自己决定，相应的，难度也极大。在完成本版本的发行版开发后，可以考虑将第一步rootfs的搭建替换为lfs。事实上，debootstrap脚本的源码，就是lfs中的一顿折腾。 # 3.3 配置软件包管理器 Finux基于Debian进行开发，使用apt包管理器。 # 3.3.1 apt(debootstrap) debootstrap拉取的debian文件系统已经自带deb系的apt包管理器。我们只需要更新apt仓库源为阿里源： 修改源文件如下： # 3.3.2 pacman (debootstrap) 如果想使用debian的文件系统，但不想使用deb系的apt，可以采用这种办法。当然，这可能带来隐患。由于我们即将在子系统上编译构建debian，因此我们需要有一个切换到根文件的辅助脚本，帮助我们完成挂载宿主系统的相关信息。 根切换脚本内容如下： 接着切换到子系统（之后将本机称为宿主系统，本机上的finux文件系统称为子系统）： 下载pacman源码： 安装pacman： 这之后就可以使用pacman替代apt包管理工具了。 # 3.3.3 pacman/apt (非debootstrap) 如果使用busybox或者lfs构建根文件系统，没有自带包管理器，将不能自动解决包依赖的问题。这时候需要检查pacman/apt的依赖，手动安装所有依赖。例如，在下文将列出apt包的部分逐层依赖： 可以看到，apt的依赖非常复杂，包含多层依赖关系。事实上，深层软件包还有可能和浅层软件包依赖发生关系。因此，手动安装包管理工具并不是一件容易的事情，笔者还是推荐搭配debootstrap使用自带的apt管理工具。 # 3.4 编译内核 Finux的内核版本为5.7.12。 # 3.4.1 获取内核 可以在获得最新的linux kernel文件。 我们使用wget命令获取kernel的源码压缩包： 压缩包是.tar.xz格式，这是两层压缩。外层是xz压缩，里层是tar压缩，所以分两步实现解压。 可以看到源代码的结构如下： # 3.4.2 安装依赖 编译内核之前，我们需要先安装编译工具的相关依赖： # 3.4.3 内核相关配置 linux的内核使用KBUILD系统进行编译，我们可以事先调整KBUILD的参数实现内核参数的定制。相关参数的文档可以在查询，也可以直接查看源代码。比如通过查看下面这一段脚本，我们可以知道如何定制内核名字和内核版本。 然后启动图形配置界面自动生成kernel编译的相关参数。 按→键选择Exit之后回车退出，即可生成配置文件。然后我们就可以开始编译和安装了。 # 3.4.4 编译安装内核 编译内核： 如果宿主机的CPU有多个内核，也可以启动多核编译。不过如果出现错误，多核编译因为不是序列式编译，debug会变得更加困难。笔者建议先用多核并行编译，如果出现错误，再用单核编译进行调试。 多核编译，-j参数用于指定使用的CPU内核数量。 内核的编译较为费时，需要等待半小时到一小时不等。编译完成后，先进行模块的安装。 ❕ 注意此处不需要安装所有模块，下面一句为不推荐的安装指令。这句指令会将所有模块关联到kernel和initrd，造成生成的initrd大小十分巨大（大约600MB），是正常情况下的十倍。如果bootloader使用这个initrd进行启动引导，会导致启动加载变慢，并且对内存要求较高。 为解决这个问题，可以加一个跳过不必需模块的参数INSTALL_MOD_STRIP=1。模块安装完成后，就可以进行内核的安装。 make install指令会自动在/boot目录下生成vmlinuz和initrd.img镜像和相关配置文件。除此之外，我们还需要检查默认的软链接是否正确。在本机上测试，默认情况下会出错，这个时候就需要纠正： # 3.5 图形化环境定制 # 3.5.1 tty登录提示 在目前的情况下，我们还没有安装桌面环境。此时只能通过tty进行用户登录。既然是自制发行版，干脆把tty也做的炫酷一些。 tty的登录提示和欢迎信息由/etc/issue和/etc/motd控制。/etc/issue与/etc/motd区别在于：当一个网络用户或通过串口登录系统 上时，/etc/issue的文件内容显示在login提示符之前，而/etc/motd内容显示在用户成功登录系统之后。 我们先改login提示符之前的信息，也就是/etc/issue。 两个文件的内容都改为： \\d为显示本地端时间日期，\\l为显示为第几个tty终端机接口，\\m显示硬件架构，\\n显示主机网络名称，\\s为显示操作系统名称。 接着我们修改/etc/motd。这其实是一个在启动后生成的符号链接，指向/var/run/motd。找到生成的脚本在/etc/update-motd.d中，通过修改其目录下的00-header,20-cpu-cheker,10-help-text等文件可以进行修改。 接着tty最后还会调用/etc/legal，我们也对其进行修改。 文件中的图形效果由boxes程序生成。 至此tty登录提示定制完成。 # 3.5.2 桌面环境 Finux采用kde桌面环境。选择它的原因是它比较现代化，而且在ArchWiki上有较为详细的文档易于参考。与apt类似的，手动配置依赖安装桌面环境是一个非常折磨人的过程，因此笔者也选择用apt包管理工具自动安装它的依赖。 安装桌面环境之前，我们首先安装桌面环境管理器。kde桌面环境可用的管理器有lightdm和sddm等。Finux使用的是lightdm。 接着安装kde桌面环境，这里可以选择安装kde-plasma或者kde-standard。前者为kde桌面环境的最小化安装，可能会缺少一些组件，我们选择安装第二个。 检查现有资源： 编写lightdm配置文件： # 3.5.3 登录会话 可以选择安装的登录会话器有lightdm-kde-greeter，lightdm-gtk-greeter和lightdm-unity-greeter等。和kde风格完美适配的是lightdm-kde-greeter，但是不知道为什么，apt软件仓库并没有收录这个软件包。因此Finux采用lightdm-gtk-greeter。 安装lightdm-gtk-greeter： 然后在lightdm的配置文件中添加greeter启动项： lightdm-gtk-greeter自己的配置文件在同目录下： 我们只讲登录会话的背景设置为黑色。 # 3.5.4 启动动画 启动动画由软件包plymouth控制，已经由脚本debootstrap自动安装进文件系统。更多自定义自动动画可以到下载。Finux采用的启动动画可在guide的同级目录build_src/plymouth下找到。将Vinyl.tar.bz复制到根文件系统并解压缩。 接着我们进行启动动画的安装。plymouth主题存放路径已经变了，而网络上的主题还是对应的老版路径，那就是/lib/plymouth/themes/，之后已改为/usr/share/plymouth/themes/，所以我们首先更改一下配置文件： 修改为如下内容： 然后进行安装： 最后更新一下initramfs完成动画安装： # 3.6 软件定制 # 3.6.1 通过apt定制 安装文本编辑器Vim： 安装火狐浏览器： 安装neofetch： # 3.6.2 从网络上获取deb包定制 在与guide同级的build_src/software下找到相应的*.deb软件包。 安装vscode： 安装网易云音乐： # 3.7 添加安装器 Finux采用calamares作为安装器。Calamares是一个独立于发行版的系统安装程序，它具有先进的自动化模块序列功能，可以方便地部署在任何发行版上。Ubuntu已经在计划使用Calamares为默认安装器。 # 3.7.1 获取安装calamares 笔者选择从源代码构建calamares： 笔者由于已经使用过宿主机一段时间的原因，在安装其他软件的时候已经安装过依赖文件。若读者想要从源代码构建calamares，可以用apt-cache depends calamares查询calamares相关的依赖： # 3.7.2 相关配置文件 calamares配置的具体说明可以在项目的github界面上找到，这里简单的带过说明。calamares的安装过程遵循用户自定义的模块化序列流程，分为可视化序列和执行序列。其中，可视化序列是和用户交互的窗口；执行序列，则是根据用户的输入，在安装过程中进行的一系列流程。 首先新建calamares的配置文件： 以下为settings.conf的 文件内容： 这些模块有的需要独立的配置文件，有的则不需要。如果不清楚，可以尝试在终端运行一遍sudo calamares，如若缺少相关配置文件，calamares会给出提示。注意，请在宿主机环境下运行宿主机的calamares进行测试，因为它需要活跃的图形环境。 经测试，对于上述执行序列，需要配置文件的模块有：bootloader, fstab.conf, machineid, partition, welcome, displaymanager, grubcfg, mount, unpackfs, finished, locale, pakages, users。它们的配置放置在/etc/calamares/modules目录下： 这里只展开其中welcome.conf的内容，其他文件可以在与guide同级的build_src/calamares/modules中找到。以下为welcome.conf的内容： 这个配置文件描述的是加载启动器后最开始的欢迎界面。其中requirements字段中分别指明了最小安装空间为8G和最小内存需求为500M。事实上，这些数值笔者并没有测试过，因此没有确切保证。之后的required字段指明了需要满足空间、内存需求和root权限。 观察到settings.conf文件中的branding字段使用了finux。这表明在和用户交互的图形化界面中，将使用/etc/calamares/branding/finux文件夹中的配置文件进行定制化。这里只展开它的配置文件branding.desc： 这表明安装器将以全屏模式启动，使用指定的图片作为logo和欢迎界面图片。其中slideshow字段指明了安装过程中将使用该脚本进行ppt效果的图片呈现。 其他文件可以在与guide同级目录下的build_src/calamares/branding/finux文件夹下找到。 # 3.8 其他工作 # 3.8.1 添加calamares桌面入口 现在需要在kde桌面环境启动后，添加calamares安装程序的桌面入口。由于文件系统是从零创建的并且桌面环境同样如此，而且live session user是在liveCD的初始化过程被添加的，这就意味着，在我们工作的时候，是没有相关的用户目录和kde桌面配置文件的。因此，我们无法直接在文件系统中添加桌面入口。 幸运的是，lightdm提供了数种hook，给用户在不同的时间段运行不同的脚本。 首先修改lightdm的配置文件： 由于不太清楚这些阶段的边界，因此干脆直接全部调用。然后我们创建“负责创建桌面入口”的脚本： 脚本内容如下： # 3.8.2 硬件检测软件包 # 3.8.3 发行版信息 LSB是Linux Standard Base的缩写， lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。lsb_release相关的配置文件在/etc/lsb-release： /etc/os-release与/usr/lib/os-release 文件包含了操作系统识别数据。修改它们的内容如下： # 3.9 制作liveCD镜像 linux可以使用grub或者isolinux进行引导。 Finux-liveCD使用isolinux进行引导，Finux使用grub进行引导。 # 3.9.1 casper casper是配合squashfs使用的一个脚本程序，它会改变initrd的内容。squashfs的全称是squash-file-system，他是一种高度压缩的文件系统，可以大大减小空间占用量。相比较直接使用暴露的文件系统，我们会先将文件系统压缩成squashfs格式，并向bootloader的命令行传入boot=casper参数。 由于initrd混合了casper，它会识别出这个参数并调用casper相应的脚本，将格式为squashfs的文件系统解压出来放入内存。 # 3.9.2 isolinux syslinux是一个轻量级的启动装载器，只用Windows的人可能不明白是什么东西，如果玩过Linux，一定知道lilo和grub，是的，所谓轻量级我想就是跟grub们相比而言的，尤其是grub2。syslinux有很多变种（都是官方的）适用于各种媒质，如syslinux用于从微软的文件系统fat 16/32引导，isolinux用于从光盘引导，pexlinux用于从网络引导，extlinux用于从ext2/3文件系统引导。 下面的内容在宿主机环境中操作。 在与guide目录同级的build_src/syslinux文件夹下找到syslinux源码压缩包，解压并安装。 # 3.9.3 制作镜像 首先下载squashfs压缩工具和制作镜像工具： 接着创建镜像相关文件夹： 接着我们要把根文件系统压缩成squashfs格式，我们使用一个脚本gen-sfs.sh完成这件事： 其中-e参数表示剔除该文件夹不计入压缩归档。 接着我们需要将在rootfs/boot中的vmlinuz和initrd复制到外部。这是因为，isolinux视图加载核和虚拟文件系统之前，根文件系统并没有被解压出来，待在其中的vmlinuz和initrd也就无法访问，因此需要将它们暴露在外部。 这之后，我们需要进行isolinux的配置。 文件内容如下： 在这个配置文件中，笔者定义了三个启动入口。其中第一个入口为安装系统liveCD，第二个入口为内存自检。isolinux_background.png为背景图片，可以在与guide目录同级的build_src/isolinux目录下找到。 然后我们需要将isolinux的相关模块放进isolinux和install文件夹。比如在上面的配置中，我们就显式得使用了vesamenu.c32模块。 ❕ 这里本来应该使用/usr/lib/syslinux/modules/bios/中的c32模块，但是奇怪的是我编译出的6.04版本的syslinux似乎不兼容5.7.12的内核，会引发kernel panic错误。于是我换成了6.03版本的编译产物，可以在build_src/isolinux/modules下找到。 最后就只剩下制作镜像了，我们依旧使用一个脚本gen-image.sh来帮助完成这件事： 可以看到，在制作镜像之前，我们还写入把镜像相关的信息付给了磁盘标识符.disk文件夹，这个文件夹在casper脚本执行的过程中也会被用到。 最后运行脚本，大功告成！ # 4 心得和体会 作为一个刚刚接触linux系统、各种意义上的小白，在上课听说季老师说可以自己写发行版的时候，我内心感到激动又向往——如果能有一个自己的发行版，那该是多么酷的一件事！但是，这个梦想实施起来的过程却异常艰辛。 首先，网络上关于制作linux发行版资料很少、并且简略，它们大多都互相抄袭，最终指向Linux From Scratch。而Linux From Scratch仅仅是从零搭建根文件系统的流程，离真正的发行版相差甚远，并且难度对于初学者来说异常高。在这样的情况下，我只能上Stack Overflow，Ask Ubuntu，Super User等论坛先咨询方向。然后再根据零星的关键词找到零星的软件，再查看诸如Ubuntu Wiki，Arch Wiki之类的文档。这个过程非常考验我独立解决问题、浏览文档的能力。 然而有很多问题是文档和论坛都不会有的。比如为什么会出现kernel panic？这串exit code代表了什么？我需要首先查看错误码的含义，猜测问题出现在内存大小上，然后再定位到大小过大的initrd，然后再找到编译内核过程中的问题，逐渐细化并解决问题。再比如calamares安装器的相关使用，相比较其他的开源项目，它的文档编写实在是太差了。差到需要亲自去查看它的源代码才能明白配置文件该怎么写。需要看源代码的还有casper，由于casper的安装会更改initrd（这是我之后才知道的），出现问题后我就解压initrd看其中的init内容，发现调用了casper脚本，再去casper脚本源码中找到确实了.disk信息。 我觉得，做发行版可能不能提升太多脚本编写的能力，但会大大加强对系统底层的认识。从bootloader，kernel，initramfs。再到/sbin/init，casper和squashfs，紧接着再到systemd，xorg，再到lightdm和DE，一个系统从启动到运行的阶段被拆分开来，清晰地呈现在我的眼前。在配置lightdm的时候，我曾经遇到过很奇怪的问题：kde的桌面环境总是加载失败。为此，我查看了/var/log下的错误日志，发现是xorg没有被授予相关权限，导致初始化失败。而这仅仅是因为我不小心用了chown修改了文件夹所有者。 总的来说，这个发行版还有很多可以完善的地方。首先，它使用现成的脚本来搭建rootfs，但是其实lfs提供了一套更自由的从零开始的方法。其次，由于使用apt的原因，它并没有自己的软件包仓库，一个完整的发行版应该有自己的软件包仓库和软件包管理器。最后，比起把所有软件集成到liveCD中，可以在image中建立partial mirror，使得安装器在安装过程中自动集成相关软件包。希望在以后的学习生活中，可以继续完善FInux！"}]